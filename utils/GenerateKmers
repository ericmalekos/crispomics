#!/usr/bin/env python3

'''
    This script slightly modifies "generate_kmers.py" script from the Guidescan repo

    EX Usage:
        GenerateKmer --pam NGG  --kmer-length 20  ./chr21Index/chr21.fa --discard_poly_T

'''
import pandas as pd
from io import StringIO
from Bio import SeqIO
import argparse
from pathlib import Path

def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Generates a set of kmers for processing by Guidescan2."
    )

    parser.add_argument(
        "-f", "--fasta",
        type=str,
        help="FASTA file to use as a reference for kmer generation.",
        required=True
    )

    parser.add_argument(
        "-k", "--keep_exact_matches",
        help="Keep guides even if they have exact matches to multiple sites. \
            This will speed up downstream analysis, but requires more RAM [default: False]",
        default=False
    )

    parser.add_argument(
        "-p", "--pam",
        type=str,
        help="Protospacer adjacent motif to match.",
        default="NGG"
    )

    parser.add_argument(
        "-l", "--kmer_length",
        help="Length of kmers to generate.",
        type=int,
        default=20
    )

    parser.add_argument(
        "--min_chr_length",
        help="Minimum chromosome length to consider for kmer generation.",
        type=int,
        default=1
    )

    parser.add_argument(
        "--prefix",
        help="Prefix to use for kmer identifiers.",
        type=str,
        default=""
    )

    parser.add_argument(
        "--discard_poly_T",
        help="Whether to discard polyT (>TTT) kmers. \
            Recommend True for PolIII promoters [default: False]",
        default=False,
        action="store_true"
    )

    
    parser.add_argument(
        "--restriction_patterns",
        help="Reject kmers with these restriction patterns. \
            Also checks 5'flank+kmer+3'flank if provided. \
            For multiple values separate by space. \
            e.g. GCGGCCGC TCTAGA CACCTGC",
        type=str,   
        default="",
        nargs='*'
    )

    parser.add_argument(
        "--flank_5",
        help="include the 5' context of the lentivirus vector. \
            Used in conjunction with --restriction_patterns to \
            remove incompatible kmers",
        type=str,
        default=""
    )
    parser.add_argument(
        "--flank_3",
        help="include the 3' context of the lentivirus vector. \
            Used in conjunction with --restriction_patterns to \
            remove incompatible kmers",
        type=str,
        default=""
    )


    return parser.parse_args()

NUCS = list("ACTG")
NUC_MAP = {"A": "T", "T": "A", "C": "G", "G": "C"}

def revcom(dna):
    return "".join(list(map(lambda n: NUC_MAP[n], list(dna)))[::-1])

def generate_pam_set(pam):
    pam_stack = [pam]

    while any(["N" in pam for pam in pam_stack]):
        pam = pam_stack.pop(0)

        if "N" not in pam:
            pam_stack.append(pam)
            continue 

        for nuc in NUCS:
            pam_stack.append(pam.replace("N", nuc, 1))

    return pam_stack

def find_kmers(pam, k, chrm, forward=True):
    index = 0

    while True:
        index = chrm.find(pam, index)

        if index == -1:
            break 

        if forward:
            kmer = chrm[index - k:index]
            context = chrm[index - k - 5:index + 5]
            position = index - k
        else:
            kmer = chrm[index + len(pam):index + k + len(pam)]
            context = chrm[index - 2:index + k + len(pam) + 5]
            position = index

        index += 1

        if position < 0:
            continue

        # Return the 1-indexed position to caller
        yield kmer.upper(), position+1, context.upper()

def find_all_kmers(pam, k, chrm): #, end=True
    """
    Generate all k-mers in a chromosome sequence that are adjacent to a given Protospacer Adjacent Motif (PAM).

    This function considers both the forward and reverse strands of the DNA.

    Parameters
    ----------
    pam : str
        The Protospacer Adjacent Motif (PAM) sequence. This function will consider all possible sequences that can be formed from the PAM considering degenerate bases.
    k : int
        The length of the k-mer to find.
    chrm : str
        The chromosome sequence in which to find k-mers.

    Yields
    ------
    dict
        A dictionary with the following keys:
        - "sequence" : The k-mer sequence.
        - "position" : The position of the left-most nucleotide of the kmer-PAM sequence.
        NOTE: for sequences on the *negative* strand this will return the position of the leftmost 'G'
        of the pam sequence from e.g. GGN-[kmerseq]. For sequences on the positive strand, this will return
        the 5'-most nucleotide of kmerseq from e.g. [kmerseq]-NGG. 
        - "pam" : The PAM pattern (NGG) that the k-mer is adjacent to.
        - "sense": The strand of the k-mer. "+" or "-".
        - "length" : k
    """
    chrm = str(chrm).upper()
    pam_set = generate_pam_set(pam)
    rev_pam_set = list(map(revcom, pam_set))

    for p in pam_set:
        for kmer, pos, context in find_kmers(p, k, chrm):
            if len(kmer) != k: continue
            if not all(nuc in NUCS for nuc in context): continue
            yield {"sequence" : kmer, "position" : pos, "pam" : pam,
                    "sense": "+", "length" : k, "context": context}

    for p in rev_pam_set:
        for kmer, pos, context in find_kmers(p, k, chrm, forward=False):
            if len(kmer) != k: continue
            if not all(nuc in NUCS for nuc in context): continue
            yield {"sequence" : revcom(kmer), "position" : pos,
                   "pam" : pam, "sense": "-", "length" : k, "context": revcom(context)}

def output_bed_line(prefix, chrm_name, kmer):
    """
    Generate and print a BED format line for a given k-mer.

    This function generates an identifier for the k-mer, prepares an entry string with necessary details, 
    and calculates the cleavage site positions. The result is printed in a tab-separated BED format.

    Parameters
    ----------
        See output from `find_all_kmers()`

    Outputs
    -------
    Prints a line in BED format with the following fields:
        - chromosome name
        - cleavage site start position
        - cleavage site end position
        - guideScanEntry, a string with the k-mer identifier, sequence, PAM, chromosome name, position, 
        and strand concatenated with commas. This is the original output of the generate_kmers.py script 
        - score (fixed as "0" in this function)
        - strand of the k-mer
    """
        
    identifier = f"{prefix}{chrm_name}:{kmer['position']}:{kmer['sense']}"
    guideScanEntry = ",".join([identifier, str(kmer['sequence']),
           kmer['pam'], chrm_name,
           str(kmer['position']), kmer['sense']])
    
    # Find the position of the Cleavage site 
    if kmer['sense'] == "+":
        cleavePos1 = kmer['position'] + kmer['length'] - 4
        cleavePos2 = kmer['position'] + kmer['length'] - 3
    else:
        cleavePos1 = kmer['position'] + 6
        cleavePos2 = kmer['position'] + 7
    
    bedLine = [chrm_name, str(cleavePos1), str(cleavePos2), guideScanEntry, kmer['context'], kmer['sense']]
    return "\t".join(bedLine)

def remove_exact_matches(kmerDF):
    kmerCounts = kmerDF[1].value_counts()

    # Get a boolean mask of kmers appearing only once
    mask = kmerDF[1].isin(kmerCounts[kmerCounts == 1].index)

    # Apply the mask to the DataFrame
    return (kmerDF[mask])

def remove_restricted(kmer, patterns, flank_5, flank_3):
    context = flank_5 + kmer + flank_3
    for pattern in patterns:
        if (pattern in context) or (pattern in revcom(context)):
            return True

    return False

if __name__ == "__main__":
    args = parse_arguments()


    Path("./tmp/").mkdir(parents=True, exist_ok=True)

    output = "./tmp/kmers.bed"

    # If exact matches are kept, output everything.
    if args.keep_exact_matches:
        for record in SeqIO.parse(args.fasta, "fasta"):
            if len(record) < args.min_chr_length:
                continue

            with open(output, 'w') as f:
                for kmer in find_all_kmers(args.pam, args.kmer_length, record.seq):

                    if args.discard_poly_T and "TTTT" in kmer["sequence"]:
                        continue

                    elif len(args.restriction_patterns) > 0 and \
                        remove_restricted(kmer["sequence"], args.restriction_patterns, \
                                          args.flank_5, args.flank_3):
                        continue    

                    else:
                        f.write(output_bed_line(args.prefix, record.name, kmer) + "\n")

    # If exact matches are removed at this stage, output only unique kmers are retained
    # implementation is quick but memory intensive
    else:
        allKmers = StringIO()
        for record in SeqIO.parse(args.fasta, "fasta"):
            if len(record) < args.min_chr_length:
                continue

            for kmer in find_all_kmers(args.pam, args.kmer_length, record.seq):

                if args.discard_poly_T and "TTTT" in kmer["sequence"]:
                    continue

                elif len(args.restriction_patterns) > 0 and \
                    remove_restricted(kmer["sequence"], args.restriction_patterns, \
                                        args.flank_5, args.flank_3):
                    continue    

                else:
                    allKmers.write(output_bed_line(args.prefix, record.name, kmer) + "\n")
        
        allKmers.seek(0)
        
        reducedKmers = remove_exact_matches(pd.read_csv(allKmers, sep=',', header=None))
        reducedKmers.to_csv(output,index=None, header=None)