#!/usr/bin/env python3

'''
    This script slightly modifies "generate_kmers.py" script from the Guidescan repo

    EX Usage:
        GenerateKmerBED --pam NGG,NAG  --kmer-length 20  ./chr21Index/chr21.fa

'''

from Bio import SeqIO
import argparse

def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Generates a set of kmers for processing by Guidescan2."
    )

    parser.add_argument(
        "fasta",
        type=str,
        help="FASTA file to use as a reference for kmer generation."
    )

    parser.add_argument(
        "--pam",
        help="Protospacer adjacent motif to match.",
        default="NGG"
    )

    parser.add_argument(
        "--kmer_length",
        help="Length of kmers to generate.",
        type=int,
        default=20
    )

    parser.add_argument(
        "--min_chr_length",
        help="Minimum chromosome length to consider for kmer generation.",
        type=int,
        default=0
    )

    parser.add_argument(
        "--prefix",
        help="Prefix to use for kmer identifiers.",
        default=""
    )

    return parser.parse_args()

NUCS = list("ACTG")
NUC_MAP = {"A": "T", "T": "A", "C": "G", "G": "C"}

def revcom(dna):
    return "".join(list(map(lambda n: NUC_MAP[n], list(dna)))[::-1])

def generate_pam_set(pam):
    pam_stack = pam.split(",")

    while any(["N" in pam for pam in pam_stack]):
        pam = pam_stack.pop(0)

        if "N" not in pam:
            pam_stack.append(pam)
            continue 

        for nuc in NUCS:
            pam_stack.append(pam.replace("N", nuc, 1))

    return pam_stack

def find_kmers(pam, k, chrm, forward=True):
    index = 0

    while True:
        index = chrm.find(pam, index)

        if index == -1:
            break 

        if forward:
            kmer = chrm[index - k:index]
            position = index - k
        else:
            kmer = chrm[index + len(pam):index + k + len(pam)]
            position = index

        index += 1

        if position < 0:
            continue

        # Return the 1-indexed position to caller
        yield kmer.upper(), position+1

def find_all_kmers(pam, k, chrm): #, end=True
    """
    Generate all k-mers in a chromosome sequence that are adjacent to a given Protospacer Adjacent Motif (PAM).

    This function considers both the forward and reverse strands of the DNA.

    Parameters
    ----------
    pam : str
        The Protospacer Adjacent Motif (PAM) sequence. This function will consider all possible sequences that can be formed from the PAM considering degenerate bases.
    k : int
        The length of the k-mer to find.
    chrm : str
        The chromosome sequence in which to find k-mers.

    Yields
    ------
    dict
        A dictionary with the following keys:
        - "sequence" : The k-mer sequence.
        - "position" : The position of the left-most nucleotide of the kmer-PAM sequence.
        NOTE: for sequences on the *negative* strand this will return the position of the leftmost 'G'
        of the pam sequence from e.g. GGN-[kmerseq]. For sequences on the positive strand, this will return
        the 5'-most nucleotide of kmerseq from e.g. [kmerseq]-NGG. 
        - "pam" : The PAM sequence that the k-mer is adjacent to.
        - "sense": The strand of the k-mer. "+" or "-".
        - "length" : k
    """
    chrm = str(chrm).upper()
    pam_set = generate_pam_set(pam)
    rev_pam_set = list(map(revcom, pam_set))

    for p in pam_set:
        for kmer, pos in find_kmers(p, k, chrm):
            if len(kmer) != k: continue
            if not all(nuc in NUCS for nuc in kmer): continue
            yield {"sequence" : kmer, "position" : pos, "pam" : p,
                    "sense": "+", "length" : k}

    for p in rev_pam_set:
        for kmer, pos in find_kmers(p, k, chrm, forward=False):
            if len(kmer) != k: continue
            if not all(nuc in NUCS for nuc in kmer): continue
            yield {"sequence" : revcom(kmer), "position" : pos,
                   "pam" : revcom(p), "sense": "-", "length" : k}

def output_kmer(prefix, chrm_name, kmer):
    """
    Generate and print a BED format line for a given k-mer.

    This function generates an identifier for the k-mer, prepares an entry string with necessary details, 
    and calculates the cleavage site positions. The result is printed in a tab-separated BED format.

    Parameters
    ----------
        See output from `find_all_kmers()`

    Outputs
    -------
    Prints a line in BED format with the following fields:
        - chromosome name
        - cleavage site start position
        - cleavage site end position
        - guideScanEntry, a string with the k-mer identifier, sequence, PAM, chromosome name, position, 
        and strand concatenated with commas. This is the original output of the generate_kmers.py script 
        - score (fixed as "0" in this function)
        - strand of the k-mer
    """
        
    identifier = f"{prefix}{chrm_name}:{kmer['position']}:{kmer['sense']}"
    guideScanEntry = ",".join([identifier, str(kmer['sequence']),
           kmer['pam'], chrm_name,
           str(kmer['position']), kmer['sense']])
    
    # Find the position of the Cleavage site 
    if kmer['sense'] == "+":
        cleavePos1 = kmer['position'] + kmer['length'] - 4
        cleavePos2 = kmer['position'] + kmer['length'] - 3
    else:
        cleavePos1 = kmer['position'] + 6
        cleavePos2 = kmer['position'] + 7
    
    bedLine = [chrm_name, str(cleavePos1), str(cleavePos2), guideScanEntry, "0", kmer['sense']]
    print("\t".join(bedLine))

if __name__ == "__main__":
    args = parse_arguments()

    #print("id,sequence,pam,chromosome,position,sense")
    for record in SeqIO.parse(args.fasta, "fasta"):
        if len(record) < args.min_chr_length:
            continue

        for kmer in find_all_kmers(args.pam, args.kmer_length, record.seq):
            output_kmer(args.prefix, record.name, kmer)
